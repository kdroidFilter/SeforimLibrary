This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
core/
  src/
    commonMain/
      kotlin/
        io/
          github/
            kdroidfilter/
              seforimlibrary/
                core/
                  extensions/
                    LineExtensions.kt
                  models/
                    Book.kt
                    Category.kt
                    Line.kt
                    LineTocMapping.kt
                    Link.kt
                    Metadata.kt
                    SearchResult.kt
                    TocEntry.kt
  build.gradle.kts
dao/
  src/
    commonMain/
      kotlin/
        io/
          github/
            kdroidfilter/
              seforimlibrary/
                dao/
                  extensions/
                    ModelExtensions.kt
                  repository/
                    SeforimRepository.kt
      sqldelight/
        io/
          github/
            kdroidfilter/
              seforimlibrary/
                db/
                  BookQueries.sq
                  CategoryQueries.sq
                  Database.sq
                  LineQueries.sq
                  LinkQueries.sq
                  SearchQueries.sq
                  TocQueries.sq
  build.gradle.kts
generator/
  src/
    commonMain/
      kotlin/
        io/
          github/
            kdroidfilter/
              seforimlibrary/
                generator/
                  Generator.kt
                  Main.kt
  build.gradle.kts
gradle/
  wrapper/
    gradle-wrapper.properties
  libs.versions.toml
sample/
  composeApp/
    src/
      androidMain/
        kotlin/
          sample/
            app/
              main.kt
        AndroidManifest.xml
      commonMain/
        kotlin/
          sample/
            app/
              App.kt
      jvmMain/
        kotlin/
          sample/
            app/
              main.kt
    build.gradle.kts
.gitignore
build.gradle.kts
gradle.properties
gradlew
gradlew.bat
README.MD
settings.gradle.kts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/extensions/LineExtensions.kt">
package io.github.kdroidfilter.seforimlibrary.core.extensions

import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.LineTocMapping

/**
 * Extensions pour faciliter la transition vers la nouvelle structure sans tocEntryId
 */

/**
 * Permet de récupérer la première entrée TOC associée à cette ligne
 * (à utiliser avec une liste de LineTocMapping)
 */
fun Line.findTocEntryId(mappings: List<LineTocMapping>): Long? {
    return mappings.firstOrNull { it.lineId == this.id }?.tocEntryId
}

/**
 * Permet de savoir si cette ligne a une entrée TOC associée
 */
fun Line.hasTocEntry(mappings: List<LineTocMapping>): Boolean {
    return mappings.any { it.lineId == this.id }
}
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Book.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Représente un livre dans la bibliothèque
 */
@Serializable
data class Book(
    val id: Long = 0,
    val categoryId: Long,
    val title: String,
    val extraTitles: List<String> = emptyList(),
    val author: String? = null,
    val heShortDesc: String? = null,
    val pubDate: String? = null,
    val pubPlace: String? = null,
    val order: Int = 999,
    val topics: String = "",
    val path: String,
    val bookType: BookType,
    val totalLines: Int = 0,
    val createdAt: Long = System.currentTimeMillis()
)

@Serializable
enum class BookType {
    TEXT, PDF
}
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Category.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Représente une catégorie dans la hiérarchie de la bibliothèque
 */
@Serializable
data class Category(
    val id: Long = 0,
    val parentId: Long? = null,
    val title: String,
    val description: String = "",
    val shortDescription: String = "",
    val order: Int = 999,
    val path: String,
    val level: Int = 0,
    val createdAt: Long = System.currentTimeMillis()
)
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Line.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Représente une ligne individuelle d'un livre
 */
@Serializable
data class Line(
    val id: Long = 0,
    val bookId: Long,
    val lineIndex: Int,
    val content: String,        // Contenu HTML original
    val plainText: String      // Texte nettoyé pour recherche
    // tocEntryId est maintenant géré via la table lineTocMapping
)
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/LineTocMapping.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Mapping entre lignes et entrées de table des matières
 */
@Serializable
data class LineTocMapping(
    val lineId: Long,
    val tocEntryId: Long
)
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Link.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Lien entre deux textes (commentaire, référence, etc.)
 */
@Serializable
data class Link(
    val id: Long = 0,
    val sourceBookId: Long,
    val targetBookId: Long,
    val heRef: String,
    val sourceLineId: Long,
    val targetLineId: Long,
    val sourceLineIndex: Int,
    val targetLineIndex: Int,
    val connectionType: ConnectionType
)

@Serializable
enum class ConnectionType {
    COMMENTARY, TARGUM, REFERENCE, OTHER;

    companion object {
        fun fromString(value: String): ConnectionType = when (value.lowercase()) {
            "commentary" -> COMMENTARY
            "targum" -> TARGUM
            "reference" -> REFERENCE
            else -> OTHER
        }
    }
}
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/Metadata.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Métadonnées d'un livre depuis le fichier JSON
 */
@Serializable
data class BookMetadata(
    val title: String,
    val description: String? = null,
    val shortDescription: String? = null,
    val author: String? = null,
    val extraTitles: List<String>? = null,
    val heShortDesc: String? = null,
    val pubDate: String? = null,
    val pubPlace: String? = null,
    val order: Int? = null
)
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/SearchResult.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Résultat de recherche
 */
@Serializable
data class SearchResult(
    val bookId: Long,
    val bookTitle: String,
    val lineId: Long,
    val lineIndex: Int,
    val snippet: String,  // Extrait avec surbrillance
    val rank: Double     // Score de pertinence
)
</file>

<file path="core/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/core/models/TocEntry.kt">
package io.github.kdroidfilter.seforimlibrary.core.models

import kotlinx.serialization.Serializable

/**
 * Entrée de la table des matières
 */
@Serializable
data class TocEntry(
    val id: Long = 0,
    val bookId: Long,
    val parentId: Long? = null,
    val text: String,
    val level: Int,
    val lineId: Long = 0,
    val lineIndex: Int,
    val order: Int,
    val path: String  // Chemin hiérarchique (ex: "1.2.3")
)
</file>

<file path="core/build.gradle.kts">
import com.vanniktech.maven.publish.SonatypeHost

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.maven.publish)
    alias(libs.plugins.kotlinx.serialization)
}

kotlin {
    jvmToolchain(17)

    androidTarget { publishLibraryVariants("release") }
    jvm()

    sourceSets {
        commonMain.dependencies {
            implementation(libs.kotlinx.serialization.json)
        }

        commonTest.dependencies {
            implementation(kotlin("test"))
        }

        androidMain.dependencies {

        }

        jvmMain.dependencies {

        }

    }

}

android {
    namespace = "io.github.kdroidfilter.seforimlibrary"
    compileSdk = 35

    defaultConfig {
        minSdk = 21
    }
}

//Publishing your Kotlin Multiplatform library to Maven Central
//https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-libraries.html
mavenPublishing {
    publishToMavenCentral(SonatypeHost.CENTRAL_PORTAL)
    coordinates("io.github.kdroidfilter.seforimlibrary", "core", "1.0.0")

    pom {
        name = "SeforimLibrary"
        description = "Kotlin Multiplatform library"
        url = "github url" //todo

        licenses {
            license {
                name = "MIT"
                url = "https://opensource.org/licenses/MIT"
            }
        }

        developers {
            developer {
                id = "" //todo
                name = "" //todo
                email = "" //todo
            }
        }

        scm {
            url = "github url" //todo
        }
    }
    if (project.hasProperty("signing.keyId")) signAllPublications()
}
</file>

<file path="dao/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/dao/extensions/ModelExtensions.kt">
package io.github.kdroidfilter.seforimlibrary.dao.extensions



import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Category
import io.github.kdroidfilter.seforimlibrary.core.models.ConnectionType
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.Link
import io.github.kdroidfilter.seforimlibrary.core.models.SearchResult
import io.github.kdroidfilter.seforimlibrary.core.models.TocEntry
import io.github.kdroidfilter.seforimlibrary.db.SearchAll
import io.github.kdroidfilter.seforimlibrary.db.SearchByAuthor
import io.github.kdroidfilter.seforimlibrary.db.SearchInBook
import io.github.kdroidfilter.seforimlibrary.db.SearchWithBookFilter
import kotlinx.serialization.json.Json
import kotlinx.serialization.decodeFromString

 fun io.github.kdroidfilter.seforimlibrary.db.Book.toModel(json: Json): Book {
    return Book(
        id = id,
        categoryId = categoryId,
        title = title,
        extraTitles = json.decodeFromString<List<String>>(extraTitles),
        author = author,
        heShortDesc = heShortDesc,
        pubDate = pubDate,
        pubPlace = pubPlace,
        order = orderIndex.toInt(),
        topics = topics,
        path = path,
        bookType = io.github.kdroidfilter.seforimlibrary.core.models.BookType.valueOf(bookType),
        totalLines = totalLines.toInt(),
        createdAt = createdAt
    )
}

fun io.github.kdroidfilter.seforimlibrary.db.Category.toModel(): Category {
    return Category(
        id = id,
        parentId = parentId,
        title = title,
        description = description,
        shortDescription = shortDescription,
        order = orderIndex.toInt(),
        path = path,
        level = level.toInt(),
        createdAt = createdAt
    )
}

fun io.github.kdroidfilter.seforimlibrary.db.Line.toModel(): Line {
    return Line(
        id = id,
        bookId = bookId,
        lineIndex = lineIndex.toInt(),
        content = content,
        plainText = plainText
    )
}

fun io.github.kdroidfilter.seforimlibrary.db.TocEntry.toModel(): TocEntry {
    return TocEntry(
        id = id,
        bookId = bookId,
        parentId = parentId,
        text = text,
        level = level.toInt(),
        lineIndex = lineIndex.toInt(),
        order = orderIndex.toInt(),
        path = path
    )
}

fun io.github.kdroidfilter.seforimlibrary.db.Link.toModel(): Link {
    return Link(
        id = id,
        sourceBookId = sourceBookId,
        targetBookId = targetBookId,
        heRef = heRef,
        sourceLineId = sourceLineId,
        targetLineId = targetLineId,
        sourceLineIndex = sourceLineIndex.toInt(),
        targetLineIndex = targetLineIndex.toInt(),
        connectionType = ConnectionType.fromString(connectionType)
    )
}


fun SearchAll.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId,
    bookTitle = bookTitle,
    lineId = lineId,
    lineIndex = lineIndex.toInt(),
    snippet = snippet,
    rank = rank.toDouble()
)

fun SearchInBook.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId,
    bookTitle = bookTitle,
    lineId = lineId,
    lineIndex = lineIndex.toInt(),
    snippet = snippet,
    rank = rank.toDouble()
)

fun SearchByAuthor.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId,
    bookTitle = bookTitle,
    lineId = lineId,
    lineIndex = lineIndex.toInt(),
    snippet = snippet,
    rank = rank.toDouble()
)

fun SearchWithBookFilter.toSearchResult(): SearchResult = SearchResult(
    bookId = bookId,
    bookTitle = bookTitle,
    lineId = lineId,
    lineIndex = lineIndex.toInt(),
    snippet = snippet,
    rank = rank.toDouble()
)
</file>

<file path="dao/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/dao/repository/SeforimRepository.kt">
package io.github.kdroidfilter.seforimlibrary.dao.repository



import app.cash.sqldelight.db.SqlDriver
import io.github.kdroidfilter.seforimlibrary.core.models.Book
import io.github.kdroidfilter.seforimlibrary.core.models.Category
import io.github.kdroidfilter.seforimlibrary.core.models.ConnectionType
import io.github.kdroidfilter.seforimlibrary.core.models.Line
import io.github.kdroidfilter.seforimlibrary.core.models.Link
import io.github.kdroidfilter.seforimlibrary.core.models.SearchResult
import io.github.kdroidfilter.seforimlibrary.core.models.TocEntry
import io.github.kdroidfilter.seforimlibrary.dao.extensions.toModel
import io.github.kdroidfilter.seforimlibrary.dao.extensions.toSearchResult
import io.github.kdroidfilter.seforimlibrary.db.SeforimDb
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import kotlinx.serialization.encodeToString
import kotlinx.serialization.decodeFromString

class SeforimRepository(databasePath: String, private val driver: SqlDriver) {
    private val database = SeforimDb(driver)
    private val json = Json { ignoreUnknownKeys = true }

    init {
        SeforimDb.Schema.create(driver)
        // Optimisations SQLite
        driver.execute(null, "PRAGMA journal_mode=WAL", 0)
        driver.execute(null, "PRAGMA synchronous=NORMAL", 0)
        driver.execute(null, "PRAGMA cache_size=10000", 0)
        driver.execute(null, "PRAGMA temp_store=MEMORY", 0)
    }

    // --- Categories ---

    suspend fun getCategory(id: Long): Category? = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun getRootCategories(): List<Category> = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.selectRoot().executeAsList().map { it.toModel() }
    }

    suspend fun getCategoryChildren(parentId: Long): List<Category> = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.selectByParentId(parentId).executeAsList().map { it.toModel() }
    }

    suspend fun insertCategory(category: Category): Long = withContext(Dispatchers.IO) {
        database.categoryQueriesQueries.insert(
            parentId = category.parentId,
            title = category.title,
            description = category.description,
            shortDescription = category.shortDescription,
            orderIndex = category.order.toLong(),
            path = category.path,
            level = category.level.toLong(),
            createdAt = category.createdAt
        )
        database.categoryQueriesQueries.lastInsertRowId().executeAsOne()
    }

    // --- Books ---

    suspend fun getBook(id: Long): Book? = withContext(Dispatchers.IO) {
        database.bookQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel(json)
    }

    suspend fun getBooksByCategory(categoryId: Long): List<Book> = withContext(Dispatchers.IO) {
        database.bookQueriesQueries.selectByCategoryId(categoryId).executeAsList()
            .map { it.toModel(json) }
    }



    suspend fun searchBooksByAuthor(author: String): List<Book> = withContext(Dispatchers.IO) {
        database.bookQueriesQueries.selectByAuthor("%$author%").executeAsList()
            .map { it.toModel(json) }
    }

    suspend fun insertBook(book: Book): Long = withContext(Dispatchers.IO) {
        database.bookQueriesQueries.insert(
            categoryId = book.categoryId,
            title = book.title,
            extraTitles = json.encodeToString(book.extraTitles),
            author = book.author,
            heShortDesc = book.heShortDesc,
            pubDate = book.pubDate,
            pubPlace = book.pubPlace,
            orderIndex = book.order.toLong(),
            topics = book.topics,
            path = book.path,
            bookType = book.bookType.name,
            totalLines = book.totalLines.toLong(),
            createdAt = book.createdAt
        )
        database.bookQueriesQueries.lastInsertRowId().executeAsOne()
    }

    suspend fun updateBookTotalLines(bookId: Long, totalLines: Int) = withContext(Dispatchers.IO) {
        database.bookQueriesQueries.updateTotalLines(totalLines.toLong(), bookId)
    }

    // --- Lines ---

    suspend fun getLine(id: Long): Line? = withContext(Dispatchers.IO) {
        database.lineQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun getLineByIndex(bookId: Long, lineIndex: Int): Line? = withContext(Dispatchers.IO) {
        database.lineQueriesQueries.selectByBookIdAndIndex(bookId, lineIndex.toLong())
            .executeAsOneOrNull()?.toModel()
    }

    suspend fun getLines(bookId: Long, startIndex: Int, endIndex: Int): List<Line> =
        withContext(Dispatchers.IO) {
            database.lineQueriesQueries.selectByBookIdRange(
                bookId = bookId,
                lineIndex = startIndex.toLong(),
                lineIndex_ = endIndex.toLong()
            ).executeAsList().map { it.toModel() }
        }

    suspend fun insertLine(line: Line): Long = withContext(Dispatchers.IO) {
        database.lineQueriesQueries.insert(
            bookId = line.bookId,
            lineIndex = line.lineIndex.toLong(),
            content = line.content,
            plainText = line.plainText,
            tocEntryId = null
        )
        database.lineQueriesQueries.lastInsertRowId().executeAsOne()
    }

    suspend fun updateLineTocEntry(lineId: Long, tocEntryId: Long) = withContext(Dispatchers.IO) {
        database.lineQueriesQueries.updateTocEntryId(tocEntryId, lineId)
    }

    // --- Table of Contents ---

    suspend fun getTocEntry(id: Long): TocEntry? = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun getBookToc(bookId: Long): List<TocEntry> = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectByBookId(bookId).executeAsList().map { it.toModel() }
    }

    suspend fun getBookRootToc(bookId: Long): List<TocEntry> = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectRootByBookId(bookId).executeAsList().map { it.toModel() }
    }

    suspend fun getTocChildren(parentId: Long): List<TocEntry> = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.selectChildren(parentId).executeAsList().map { it.toModel() }
    }

    suspend fun insertTocEntry(entry: TocEntry): Long = withContext(Dispatchers.IO) {
        database.tocQueriesQueries.insert(
            bookId = entry.bookId,
            parentId = entry.parentId,
            text = entry.text,
            level = entry.level.toLong(),
            lineId = entry.lineId,
            lineIndex = entry.lineIndex.toLong(),
            orderIndex = entry.order.toLong(),
            path = entry.path
        )
        database.tocQueriesQueries.lastInsertRowId().executeAsOne()
    }

    // --- Links ---

    suspend fun getLink(id: Long): Link? = withContext(Dispatchers.IO) {
        database.linkQueriesQueries.selectById(id).executeAsOneOrNull()?.toModel()
    }

    suspend fun getCommentariesForLines(
        lineIds: List<Long>,
        activeCommentatorIds: Set<Long> = emptySet()
    ): List<CommentaryWithText> = withContext(Dispatchers.IO) {
        database.linkQueriesQueries.selectBySourceLineIds(lineIds).executeAsList()
            .filter { activeCommentatorIds.isEmpty() || it.targetBookId in activeCommentatorIds }
            .map {
                CommentaryWithText(
                    link = Link(
                        id = it.id,
                        sourceBookId = it.sourceBookId,
                        targetBookId = it.targetBookId,
                        heRef = it.heRef,
                        sourceLineId = it.sourceLineId,
                        targetLineId = it.targetLineId,
                        sourceLineIndex = it.sourceLineIndex.toInt(),
                        targetLineIndex = it.targetLineIndex.toInt(),
                        connectionType = ConnectionType.fromString(it.connectionType)
                    ),
                    targetBookTitle = it.targetBookTitle,
                    targetText = it.targetText
                )
            }
    }

    suspend fun getAvailableCommentators(bookId: Long): List<CommentatorInfo> =
        withContext(Dispatchers.IO) {
            database.linkQueriesQueries.selectCommentatorsByBook(bookId).executeAsList()
                .map {
                    CommentatorInfo(
                        bookId = it.targetBookId,
                        title = it.targetBookTitle,
                        author = it.author,
                        linkCount = it.linkCount.toInt()
                    )
                }
        }

    suspend fun insertLink(link: Link): Long = withContext(Dispatchers.IO) {
        database.linkQueriesQueries.insert(
            sourceBookId = link.sourceBookId,
            targetBookId = link.targetBookId,
            heRef = link.heRef,
            sourceLineId = link.sourceLineId,
            targetLineId = link.targetLineId,
            sourceLineIndex = link.sourceLineIndex.toLong(),
            targetLineIndex = link.targetLineIndex.toLong(),
            connectionType = link.connectionType.name
        )
        database.linkQueriesQueries.lastInsertRowId().executeAsOne()
    }

    // --- Search ---

    suspend fun search(
        query: String,
        limit: Int = 20,
        offset: Int = 0
    ): List<SearchResult> = withContext(Dispatchers.IO) {
        val ftsQuery = prepareFtsQuery(query)
        database.searchQueriesQueries.searchAll(ftsQuery, limit.toLong(), offset.toLong())
            .executeAsList()
            .map { it.toSearchResult() }
    }

    suspend fun searchInBook(
        bookId: Long,
        query: String,
        limit: Int = 20,
        offset: Int = 0
    ): List<SearchResult> = withContext(Dispatchers.IO) {
        val ftsQuery = prepareFtsQuery(query)
        database.searchQueriesQueries.searchInBook(
            ftsQuery, bookId, limit.toLong(), offset.toLong()
        ).executeAsList().map { it.toSearchResult() }
    }

    suspend fun searchByAuthor(
        author: String,
        query: String,
        limit: Int = 20,
        offset: Int = 0
    ): List<SearchResult> = withContext(Dispatchers.IO) {
        val ftsQuery = prepareFtsQuery(query)
        database.searchQueriesQueries.searchByAuthor(
            ftsQuery, author, limit.toLong(), offset.toLong()
        ).executeAsList().map { it.toSearchResult() }
    }

    // --- Helpers ---

    private fun prepareFtsQuery(query: String): String {
        return query.trim()
            .split("\\s+".toRegex())
            .filter { it.isNotBlank() }
            .joinToString(" ") { "\"$it\"*" }
    }

    fun close() {
        driver.close()
    }
}

// Data classes pour résultats enrichis
data class CommentatorInfo(
    val bookId: Long,
    val title: String,
    val author: String?,
    val linkCount: Int
)

data class CommentaryWithText(
    val link: Link,
    val targetBookTitle: String,
    val targetText: String
)
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/BookQueries.sq">
-- Requêtes pour les livres

selectAll:
SELECT * FROM book ORDER BY orderIndex, title;

selectById:
SELECT * FROM book WHERE id = ?;

selectByCategoryId:
SELECT * FROM book WHERE categoryId = ? ORDER BY orderIndex, title;

selectByTitle:
SELECT * FROM book WHERE title = ?;

selectByPath:
SELECT * FROM book WHERE path = ?;

selectByAuthor:
SELECT * FROM book WHERE author LIKE ? ORDER BY orderIndex, title;

insert:
INSERT INTO book (categoryId, title, extraTitles, author, heShortDesc, pubDate, pubPlace, orderIndex, topics, path, bookType, totalLines, createdAt)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);

updateTotalLines:
UPDATE book SET totalLines = ? WHERE id = ?;

delete:
DELETE FROM book WHERE id = ?;

countByCategoryId:
SELECT COUNT(*) FROM book WHERE categoryId = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/CategoryQueries.sq">
-- Requêtes pour les catégories

selectAll:
SELECT * FROM category ORDER BY orderIndex, title;

selectById:
SELECT * FROM category WHERE id = ?;

selectByParentId:
SELECT * FROM category WHERE parentId = ? ORDER BY orderIndex, title;

selectRoot:
SELECT * FROM category WHERE parentId IS NULL ORDER BY orderIndex, title;

selectByPath:
SELECT * FROM category WHERE path = ?;

insert:
INSERT INTO category (parentId, title, description, shortDescription, orderIndex, path, level, createdAt)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);

update:
UPDATE category SET
    title = ?,
    description = ?,
    shortDescription = ?,
    orderIndex = ?
WHERE id = ?;

delete:
DELETE FROM category WHERE id = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/Database.sq">
-- Table des catégories
CREATE TABLE IF NOT EXISTS category (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    parentId INTEGER,
    title TEXT NOT NULL,
    description TEXT NOT NULL DEFAULT '',
    shortDescription TEXT NOT NULL DEFAULT '',
    orderIndex INTEGER NOT NULL DEFAULT 999,
    path TEXT NOT NULL UNIQUE,
    level INTEGER NOT NULL DEFAULT 0,
    createdAt INTEGER NOT NULL,
    FOREIGN KEY (parentId) REFERENCES category(id) ON DELETE CASCADE
);

CREATE INDEX idx_category_parent ON category(parentId);
CREATE INDEX idx_category_order ON category(orderIndex);
CREATE INDEX idx_category_path ON category(path);

-- Table des livres
CREATE TABLE IF NOT EXISTS book (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    categoryId INTEGER NOT NULL,
    title TEXT NOT NULL,
    extraTitles TEXT NOT NULL DEFAULT '[]',
    author TEXT,
    heShortDesc TEXT,
    pubDate TEXT,
    pubPlace TEXT,
    orderIndex INTEGER NOT NULL DEFAULT 999,
    topics TEXT NOT NULL DEFAULT '',
    path TEXT NOT NULL UNIQUE,
    bookType TEXT NOT NULL,
    totalLines INTEGER NOT NULL DEFAULT 0,
    createdAt INTEGER NOT NULL,
    FOREIGN KEY (categoryId) REFERENCES category(id) ON DELETE CASCADE
);

CREATE INDEX idx_book_category ON book(categoryId);
CREATE INDEX idx_book_title ON book(title);
CREATE INDEX idx_book_author ON book(author);
CREATE INDEX idx_book_order ON book(orderIndex);
CREATE INDEX idx_book_path ON book(path);

-- Table des lignes
CREATE TABLE IF NOT EXISTS line (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    bookId INTEGER NOT NULL,
    lineIndex INTEGER NOT NULL,
    content TEXT NOT NULL,
    plainText TEXT NOT NULL,
    tocEntryId INTEGER,
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (tocEntryId) REFERENCES tocEntry(id) ON DELETE SET NULL
);

CREATE INDEX idx_line_book_index ON line(bookId, lineIndex);
CREATE INDEX idx_line_toc ON line(tocEntryId);

-- Table des entrées TOC
CREATE TABLE IF NOT EXISTS tocEntry (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    bookId INTEGER NOT NULL,
    parentId INTEGER,
    text TEXT NOT NULL,
    level INTEGER NOT NULL,
    lineId INTEGER NOT NULL,
    lineIndex INTEGER NOT NULL,
    orderIndex INTEGER NOT NULL,
    path TEXT NOT NULL,
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (parentId) REFERENCES tocEntry(id) ON DELETE CASCADE,
    FOREIGN KEY (lineId) REFERENCES line(id) ON DELETE CASCADE
);

CREATE INDEX idx_toc_book ON tocEntry(bookId);
CREATE INDEX idx_toc_parent ON tocEntry(parentId);
CREATE INDEX idx_toc_line ON tocEntry(lineId);

-- Table des liens
CREATE TABLE IF NOT EXISTS link (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    sourceBookId INTEGER NOT NULL,
    targetBookId INTEGER NOT NULL,
    heRef TEXT NOT NULL,
    sourceLineId INTEGER NOT NULL,
    targetLineId INTEGER NOT NULL,
    sourceLineIndex INTEGER NOT NULL,
    targetLineIndex INTEGER NOT NULL,
    connectionType TEXT NOT NULL,
    FOREIGN KEY (sourceBookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (targetBookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (sourceLineId) REFERENCES line(id) ON DELETE CASCADE,
    FOREIGN KEY (targetLineId) REFERENCES line(id) ON DELETE CASCADE
);

CREATE INDEX idx_link_source ON link(sourceBookId, sourceLineIndex);
CREATE INDEX idx_link_source_line ON link(sourceLineId);
CREATE INDEX idx_link_target ON link(targetBookId, targetLineIndex);
CREATE INDEX idx_link_type ON link(connectionType);

-- Table standard pour la recherche (sans FTS5)
CREATE TABLE IF NOT EXISTS line_search (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    bookId INTEGER NOT NULL,
    lineId INTEGER NOT NULL,
    lineIndex INTEGER NOT NULL,
    bookTitle TEXT NOT NULL,
    content TEXT NOT NULL,
    FOREIGN KEY (bookId) REFERENCES book(id) ON DELETE CASCADE,
    FOREIGN KEY (lineId) REFERENCES line(id) ON DELETE CASCADE
);

CREATE INDEX idx_line_search_content ON line_search(content);
CREATE INDEX idx_line_search_book_title ON line_search(bookTitle);
CREATE INDEX idx_line_search_book_id ON line_search(bookId);
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/LineQueries.sq">
-- Requêtes pour les lignes

selectById:
SELECT * FROM line WHERE id = ?;

selectByBookId:
SELECT * FROM line WHERE bookId = ? ORDER BY lineIndex;

selectByBookIdRange:
SELECT * FROM line
WHERE bookId = ?
AND lineIndex >= ?
AND lineIndex <= ?
ORDER BY lineIndex;

selectByBookIdAndIndex:
SELECT * FROM line WHERE bookId = ? AND lineIndex = ?;

insert:
INSERT INTO line (bookId, lineIndex, content, plainText, tocEntryId)
VALUES (?, ?, ?, ?, ?);

updateTocEntryId:
UPDATE line SET tocEntryId = ? WHERE id = ?;

delete:
DELETE FROM line WHERE id = ?;

deleteByBookId:
DELETE FROM line WHERE bookId = ?;

countByBookId:
SELECT COUNT(*) FROM line WHERE bookId = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/LinkQueries.sq">
-- Requêtes pour les liens

selectById:
SELECT * FROM link WHERE id = ?;

selectBySourceLineIds:
SELECT l.*, b.title AS targetBookTitle, tl.plainText AS targetText
FROM link l
JOIN book b ON l.targetBookId = b.id
JOIN line tl ON l.targetLineId = tl.id
WHERE l.sourceLineId IN ?
ORDER BY l.sourceLineIndex, b.orderIndex;

selectBySourceBookRange:
SELECT * FROM link
WHERE sourceBookId = ?
AND sourceLineIndex >= ?
AND sourceLineIndex <= ?;

selectCommentatorsByBook:
SELECT DISTINCT l.targetBookId, b.title AS targetBookTitle, b.author, COUNT(*) AS linkCount
FROM link l
JOIN book b ON l.targetBookId = b.id
WHERE l.sourceBookId = ?
AND l.connectionType IN ('COMMENTARY', 'TARGUM')
GROUP BY l.targetBookId, b.title, b.author
ORDER BY b.orderIndex, b.title;

insert:
INSERT INTO link (sourceBookId, targetBookId, heRef, sourceLineId, targetLineId, sourceLineIndex, targetLineIndex, connectionType)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);

delete:
DELETE FROM link WHERE id = ?;

deleteByBookId:
DELETE FROM link WHERE sourceBookId = ? OR targetBookId = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/SearchQueries.sq">
-- Requêtes de recherche standard (sans FTS5)

searchAll:
SELECT
    ls.bookId,
    b.title bookTitle,
    ls.lineId,
    ls.lineIndex,
    SUBSTR(ls.content, 1, 150) snippet, -- Extrait simple du contenu
    0 rank -- Classement fixe sans FTS5
FROM line_search ls
JOIN book b ON b.id = ls.bookId
WHERE ls.content LIKE '%' || ? || '%'
ORDER BY ls.bookId, ls.lineIndex
LIMIT ? OFFSET ?;

searchInBook:
SELECT
    ls.bookId,
    b.title bookTitle,
    ls.lineId,
    ls.lineIndex,
    SUBSTR(ls.content, 1, 150) snippet,
    0 rank
FROM line_search ls
JOIN book b ON b.id = ls.bookId
WHERE ls.content LIKE '%' || ? || '%' AND ls.bookId = ?
ORDER BY ls.lineIndex
LIMIT ? OFFSET ?;

searchByAuthor:
SELECT
    ls.bookId,
    b.title bookTitle,
    ls.lineId,
    ls.lineIndex,
    SUBSTR(ls.content, 1, 150) snippet,
    0 rank
FROM line_search ls
JOIN book b ON b.id = ls.bookId
WHERE ls.content LIKE '%' || ? || '%' AND b.author = ?
ORDER BY ls.bookId, ls.lineIndex
LIMIT ? OFFSET ?;

searchWithBookFilter:
SELECT
    ls.bookId,
    b.title bookTitle,
    ls.lineId,
    ls.lineIndex,
    SUBSTR(ls.content, 1, 150) snippet,
    0 rank
FROM line_search ls
JOIN book b ON b.id = ls.bookId
WHERE ls.content LIKE '%' || ? || '%'
AND b.title LIKE '%' || ? || '%'
ORDER BY ls.bookId, ls.lineIndex
LIMIT ? OFFSET ?;

countSearchResults:
SELECT COUNT(*)
FROM line_search
WHERE content LIKE '%' || ? || '%';

-- Nouvelles requêtes pour gérer l'insertion et la mise à jour des données de recherche

insertSearchEntry:
INSERT INTO line_search (bookId, lineId, lineIndex, bookTitle, content)
VALUES (?, ?, ?, ?, ?);

updateSearchEntry:
UPDATE line_search
SET content = ?
WHERE lineId = ?;

deleteSearchEntryByLineId:
DELETE FROM line_search
WHERE lineId = ?;

deleteSearchEntriesByBookId:
DELETE FROM line_search
WHERE bookId = ?;
</file>

<file path="dao/src/commonMain/sqldelight/io/github/kdroidfilter/seforimlibrary/db/TocQueries.sq">
-- Requêtes pour la table des matières

selectByBookId:
SELECT * FROM tocEntry WHERE bookId = ? ORDER BY orderIndex;

selectById:
SELECT * FROM tocEntry WHERE id = ?;

selectRootByBookId:
SELECT * FROM tocEntry WHERE bookId = ? AND parentId IS NULL ORDER BY orderIndex;

selectChildren:
SELECT * FROM tocEntry WHERE parentId = ? ORDER BY orderIndex;

selectByLineId:
SELECT * FROM tocEntry WHERE lineId = ?;

insert:
INSERT INTO tocEntry (bookId, parentId, text, level, lineId, lineIndex, orderIndex, path)
VALUES (?, ?, ?, ?, ?, ?, ?, ?);

delete:
DELETE FROM tocEntry WHERE id = ?;

deleteByBookId:
DELETE FROM tocEntry WHERE bookId = ?;

lastInsertRowId:
SELECT last_insert_rowid();
</file>

<file path="dao/build.gradle.kts">
import com.vanniktech.maven.publish.SonatypeHost

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.android.library)
    alias(libs.plugins.maven.publish)
    alias(libs.plugins.kotlinx.serialization)
    alias(libs.plugins.sqlDelight)
}

kotlin {
    jvmToolchain(17)

    androidTarget { publishLibraryVariants("release") }
    jvm()

    sourceSets {
        commonMain.dependencies {
            api(project(":core"))
            implementation(libs.kotlinx.coroutines.core)
            implementation(libs.kotlinx.coroutines.test)
            implementation(libs.kotlinx.serialization.json)
            implementation(libs.kotlinx.datetime)
            implementation(libs.kermit)
        }

        commonTest.dependencies {
            implementation(kotlin("test"))
        }

        androidMain.dependencies {
            implementation(libs.kotlinx.coroutines.android)
            implementation(libs.sqlDelight.driver.android)
        }

        jvmMain.dependencies {
            implementation(libs.kotlinx.coroutines.swing)
            implementation(libs.sqlDelight.driver.sqlite)
        }

    }

}

android {
    namespace = "io.github.kdroidfilter.seforimlibrary"
    compileSdk = 35

    defaultConfig {
        minSdk = 21
    }
}


//Publishing your Kotlin Multiplatform library to Maven Central
//https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-publish-libraries.html
mavenPublishing {
    publishToMavenCentral(SonatypeHost.CENTRAL_PORTAL)
    coordinates("io.github.kdroidfilter.seforimlibrary", "dao", "1.0.0")

    pom {
        name = "SeforimLibraryDao"
        description = "Kotlin Multiplatform library"
        url = "github url" //todo

        licenses {
            license {
                name = "MIT"
                url = "https://opensource.org/licenses/MIT"
            }
        }

        developers {
            developer {
                id = "" //todo
                name = "" //todo
                email = "" //todo
            }
        }

        scm {
            url = "github url" //todo
        }
    }
    if (project.hasProperty("signing.keyId")) signAllPublications()
}

sqldelight {
    databases {
        create("SeforimDb") {
            // Database configuration here.
            // https://cashapp.github.io/sqldelight
            packageName.set("io.github.kdroidfilter.seforimlibrary.db")
            dialect("app.cash.sqldelight:sqlite-3-24-dialect:${libs.versions.sqlDelight.get()}")
        }
    }
}
</file>

<file path="generator/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/generator/Generator.kt">
package io.github.kdroidfilter.seforimlibrary.generator


import io.github.kdroidfilter.seforimlibrary.core.models.*
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.coroutineScope
import kotlinx.coroutines.runBlocking
import kotlinx.serialization.json.Json
import org.jsoup.Jsoup
import org.jsoup.safety.Safelist
import org.slf4j.LoggerFactory
import java.io.File
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import kotlin.io.path.exists
import kotlin.io.path.extension
import kotlin.io.path.nameWithoutExtension
import kotlin.io.path.readText

class DatabaseGenerator(
    private val sourceDirectory: Path,
    private val repository: SeforimRepository
) {
    private val logger = LoggerFactory.getLogger(javaClass)
    private val json = Json { ignoreUnknownKeys = true }

    suspend fun generate() = coroutineScope {
        logger.info("Démarrage de la génération de la base de données...")
        logger.info("Répertoire source: $sourceDirectory")

        try {
            // Charger les métadonnées
            val metadata = loadMetadata()
            logger.info("Métadonnées chargées: ${metadata.size} entrées")

            // Traiter la hiérarchie
            val libraryPath = sourceDirectory.resolve("אוצריא")
            if (!libraryPath.exists()) {
                throw IllegalStateException("Le répertoire אוצריא n'existe pas dans $sourceDirectory")
            }

            processDirectory(libraryPath, null, 0, metadata)

            // Traiter les liens
            processLinks()

            logger.info("Génération terminée avec succès!")
        } catch (e: Exception) {
            logger.error("Erreur lors de la génération", e)
            throw e
        }
    }

    private suspend fun loadMetadata(): Map<String, BookMetadata> {
        val metadataFile = sourceDirectory.resolve("metadata.json")
        return if (metadataFile.exists()) {
            val content = metadataFile.readText()
            try {
                // Try to parse as Map first (original format)
                json.decodeFromString<Map<String, BookMetadata>>(content)
            } catch (e: Exception) {
                // If that fails, try to parse as List and convert to Map
                try {
                    val metadataList = json.decodeFromString<List<BookMetadata>>(content)
                    logger.info("Parsed metadata as List with ${metadataList.size} entries")
                    // Convert list to map using title as key
                    metadataList.associateBy { it.title }
                } catch (e: Exception) {
                    logger.error("Failed to parse metadata.json", e)
                    emptyMap()
                }
            }
        } else {
            logger.warn("Fichier metadata.json introuvable")
            emptyMap()
        }
    }

    private suspend fun processDirectory(
        directory: Path,
        parentCategoryId: Long?,
        level: Int,
        metadata: Map<String, BookMetadata>
    ) {
        Files.list(directory).use { stream ->
            val entries = stream.sorted { a, b ->
                a.fileName.toString().compareTo(b.fileName.toString())
            }.toList()

            for (entry in entries) {
                when {
                    Files.isDirectory(entry) -> {
                        val categoryId = createCategory(entry, parentCategoryId, level)
                        processDirectory(entry, categoryId, level + 1, metadata)
                    }
                    Files.isRegularFile(entry) && entry.extension in listOf("txt", "docx", "pdf") -> {
                        if (parentCategoryId == null) {
                            logger.warn("Livre trouvé sans catégorie: $entry")
                            continue
                        }
                        createAndProcessBook(entry, parentCategoryId, metadata)
                    }
                }
            }
        }
    }

    private suspend fun createCategory(
        path: Path,
        parentId: Long?,
        level: Int
    ): Long {
        val title = path.fileName.toString()
        logger.info("Création de la catégorie: $title (niveau $level)")

        val category = Category(
            parentId = parentId,
            title = title,
            path = path.toString(),
            level = level,
            createdAt = System.currentTimeMillis()
        )

        return repository.insertCategory(category)
    }

    private suspend fun createAndProcessBook(
        path: Path,
        categoryId: Long,
        metadata: Map<String, BookMetadata>
    ) {
        val filename = path.fileName.toString()
        val title = filename.substringBeforeLast('.')
        val meta = metadata[title]

        logger.info("Traitement du livre: $title")

        val book = Book(
            categoryId = categoryId,
            title = title,
            extraTitles = meta?.extraTitles ?: emptyList(),
            author = meta?.author,
            heShortDesc = meta?.heShortDesc,
            pubDate = meta?.pubDate,
            pubPlace = meta?.pubPlace,
            order = meta?.order ?: 999,
            topics = extractTopics(path),
            path = path.toString(),
            bookType = if (path.extension == "pdf") BookType.PDF else BookType.TEXT,
            createdAt = System.currentTimeMillis()
        )

        val bookId = repository.insertBook(book)

        // Traiter le contenu pour les livres texte
        if (book.bookType == BookType.TEXT) {
            processBookContent(path, bookId)
        }
    }

    private suspend fun processBookContent(path: Path, bookId: Long) = coroutineScope {
        logger.info("Traitement du contenu du livre ID: $bookId")

        val content = when (path.extension) {
            "txt" -> path.readText(Charsets.UTF_8)
            "docx" -> extractDocxText(path)
            else -> {
                logger.warn("Type de fichier non supporté: ${path.extension}")
                return@coroutineScope
            }
        }

        val lines = content.lines()
        logger.info("Nombre de lignes: ${lines.size}")

        // Insérer les lignes par batch pour performance
        val lineIds = mutableListOf<Pair<Int, Long>>()
        val batchSize = 1000

        for (batch in lines.chunked(batchSize).withIndex()) {
            val startIndex = batch.index * batchSize

            for ((index, line) in batch.value.withIndex()) {
                val lineIndex = startIndex + index
                val plainText = cleanHtml(line)

                val lineId = repository.insertLine(
                    Line(
                        bookId = bookId,
                        lineIndex = lineIndex,
                        content = line,
                        plainText = plainText
                    )
                )

                lineIds.add(lineIndex to lineId)
            }

            if (batch.index % 10 == 0) {
                logger.info("Progression: ${startIndex + batch.value.size}/${lines.size} lignes")
            }
        }

        // Créer la table des matières
        createTableOfContents(bookId, lines, lineIds)

        // Mettre à jour le nombre total de lignes
        repository.updateBookTotalLines(bookId, lines.size)

        logger.info("Contenu traité avec succès pour le livre ID: $bookId")
    }

    private fun cleanHtml(html: String): String {
        return Jsoup.clean(html, Safelist.none())
            .trim()
            .replace("\\s+".toRegex(), " ")
    }

    private suspend fun createTableOfContents(
        bookId: Long,
        lines: List<String>,
        lineIds: List<Pair<Int, Long>>
    ) {
        val tocEntries = mutableListOf<TocInfo>()

        // Détecter les entrées TOC
        lines.forEachIndexed { index, line ->
            val level = detectHeaderLevel(line)
            if (level > 0) {
                val text = cleanHtml(line)
                val lineId = lineIds.find { it.first == index }?.second ?: return@forEachIndexed
                tocEntries.add(TocInfo(index, lineId, level, text))
            }
        }

        if (tocEntries.isEmpty()) return

        logger.info("Création de ${tocEntries.size} entrées TOC")

        // Créer la hiérarchie TOC
        val parentStack = mutableMapOf<Int, Long>()

        for ((order, tocInfo) in tocEntries.withIndex()) {
            val parentId = if (tocInfo.level > 1) {
                // Trouver le parent le plus proche
                (tocInfo.level - 1 downTo 1)
                    .mapNotNull { parentStack[it] }
                    .firstOrNull()
            } else null

            val path = buildTocPath(parentStack, tocInfo.level, order)

            val tocEntry = TocEntry(
                bookId = bookId,
                parentId = parentId,
                text = tocInfo.text,
                level = tocInfo.level,
                lineId = tocInfo.lineId,
                lineIndex = tocInfo.lineIndex,
                order = order,
                path = path
            )

            val tocId = repository.insertTocEntry(tocEntry)
            parentStack[tocInfo.level] = tocId

            // Mettre à jour la ligne avec la référence TOC
            repository.updateLineTocEntry(tocInfo.lineId, tocId)
        }
    }

    private fun detectHeaderLevel(line: String): Int {
        return when {
            line.startsWith("<h1", ignoreCase = true) -> 1
            line.startsWith("<h2", ignoreCase = true) -> 2
            line.startsWith("<h3", ignoreCase = true) -> 3
            line.startsWith("<h4", ignoreCase = true) -> 4
            line.startsWith("<h5", ignoreCase = true) -> 5
            line.startsWith("<h6", ignoreCase = true) -> 6
            else -> 0
        }
    }

    private fun buildTocPath(parentStack: Map<Int, Long>, level: Int, order: Int): String {
        val path = mutableListOf<Int>()
        for (i in 1..level) {
            if (i == level) {
                path.add(order + 1)
            } else {
                parentStack[i]?.let { path.add(it.toInt()) }
            }
        }
        return path.joinToString(".")
    }

    private suspend fun processLinks() {
        val linksDir = sourceDirectory.resolve("links")
        if (!linksDir.exists()) {
            logger.warn("Répertoire links introuvable")
            return
        }

        logger.info("Traitement des liens...")
        var totalLinks = 0

        Files.list(linksDir).use { stream ->
            stream.filter { it.extension == "json" }.forEach { linkFile ->
                runBlocking {
                    val processedLinks = processLinkFile(linkFile)
                    totalLinks += processedLinks
                }
            }
        }

        logger.info("Total de $totalLinks liens traités")
    }

    private suspend fun processLinkFile(linkFile: Path): Int {
        val bookTitle = linkFile.nameWithoutExtension.removeSuffix("_links")

        // Trouver le livre source
        val sourceBook = repository.getBooksByCategory(0) // TODO: rechercher par titre
            .find { it.title == bookTitle }

        if (sourceBook == null) {
            logger.warn("Livre source introuvable pour les liens: $bookTitle")
            return 0
        }

        val links = json.decodeFromString<List<LinkData>>(linkFile.readText())
        var processed = 0

        for (linkData in links) {
            try {
                // Trouver le livre cible
                val targetPath = Paths.get(linkData.path_2)
                val targetTitle = targetPath.fileName.toString().substringBeforeLast('.')

                val targetBook = repository.getBooksByCategory(0) // TODO: rechercher par titre
                    .find { it.title == targetTitle }
                    ?: continue

                // Trouver les lignes
                val sourceLine = repository.getLineByIndex(sourceBook.id, linkData.line_index_1)
                val targetLine = repository.getLineByIndex(targetBook.id, linkData.line_index_2)

                if (sourceLine != null && targetLine != null) {
                    val link = Link(
                        sourceBookId = sourceBook.id,
                        targetBookId = targetBook.id,
                        heRef = linkData.heRef_2,
                        sourceLineId = sourceLine.id,
                        targetLineId = targetLine.id,
                        sourceLineIndex = linkData.line_index_1,
                        targetLineIndex = linkData.line_index_2,
                        connectionType = ConnectionType.fromString(linkData.connectionType)
                    )

                    repository.insertLink(link)
                    processed++
                }
            } catch (e: Exception) {
                logger.error("Erreur lors du traitement du lien: ${linkData.heRef_2}", e)
            }
        }

        return processed
    }

    private fun extractTopics(path: Path): String {
        // Extraire les topics du chemin
        val parts = path.toString().split(File.separator)
        return parts.dropLast(1).takeLast(2).joinToString(", ")
    }

    private fun extractDocxText(path: Path): String {
        // TODO: Implémenter l'extraction DOCX avec Apache POI
        return ""
    }

    // Classes internes
    private data class TocInfo(
        val lineIndex: Int,
        val lineId: Long,
        val level: Int,
        val text: String
    )

    @kotlinx.serialization.Serializable
    private data class LinkData(
        val heRef_2: String,
        val line_index_1: Int,
        val path_2: String,
        val line_index_2: Int,
        @kotlinx.serialization.SerialName("Conection Type")
        val connectionType: String
    )
}
</file>

<file path="generator/src/commonMain/kotlin/io/github/kdroidfilter/seforimlibrary/generator/Main.kt">
package io.github.kdroidfilter.seforimlibrary.generator

import app.cash.sqldelight.driver.jdbc.sqlite.JdbcSqliteDriver
import io.github.kdroidfilter.seforimlibrary.dao.repository.SeforimRepository
import kotlinx.coroutines.runBlocking
import java.io.File
import java.nio.file.Paths
import kotlin.io.path.Path
import kotlin.system.exitProcess

fun main() = runBlocking {

    val driver = JdbcSqliteDriver(url = "jdbc:sqlite:otzaria.db")

    val sourcePath = Path("/home/elie-gambache/Téléchargements/otzaria (2)")
    val dbPath = Paths.get("otzaria.db").toFile().path

    if (!sourcePath.toFile().exists()) {
        println("Erreur: Le répertoire source n'existe pas: $sourcePath")
        exitProcess(1)
    }

    println("=== Générateur de base de données Otzaria ===")
    println("Source: $sourcePath")
    println("Base de données: $dbPath")
    println()

    val repository = SeforimRepository(dbPath, driver)

    try {
        val generator = DatabaseGenerator(sourcePath, repository)
        generator.generate()

        println("\nGénération terminée avec succès!")
        println("Base de données créée: $dbPath")
    } catch (e: Exception) {
        println("\nErreur lors de la génération:")
        e.printStackTrace()
        exitProcess(1)
    } finally {
        repository.close()
    }
}
</file>

<file path="generator/build.gradle.kts">
import com.vanniktech.maven.publish.SonatypeHost

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.kotlinx.serialization)
}

kotlin {
    jvmToolchain(17)

    jvm()

    sourceSets {
        commonMain.dependencies {
            api(project(":core"))
            api(project(":dao"))

            implementation(libs.kotlinx.coroutines.core)
            implementation(libs.kotlinx.coroutines.test)
            implementation(libs.kotlinx.serialization.json)
            implementation(libs.kotlinx.datetime)
            implementation(libs.kermit)
            implementation("org.jsoup:jsoup:1.17.2")
            implementation("org.slf4j:slf4j-simple:2.0.17")
        }

        commonTest.dependencies {
            implementation(kotlin("test"))
        }


        jvmMain.dependencies {
            implementation(libs.kotlinx.coroutines.swing)
            implementation(libs.sqlDelight.driver.sqlite)
        }

    }

}
</file>

<file path="gradle/wrapper/gradle-wrapper.properties">
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.14.2-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
</file>

<file path="gradle/libs.versions.toml">
[versions]

kotlin = "2.2.0"
agp = "8.9.3"
maven-publish = "0.32.0"
kotlinx-coroutines = "1.10.2"
kotlinx-serialization = "1.8.1"
kotlinx-datetime = "0.6.2"
kermit = "2.0.6"
sqlDelight = "2.1.0"
compose = "1.8.2"
androidx-activityCompose = "1.10.1"

[libraries]

kotlinx-coroutines-core = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-core", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-android = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-android", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-swing = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-swing", version.ref = "kotlinx-coroutines" }
kotlinx-coroutines-test = { module = "org.jetbrains.kotlinx:kotlinx-coroutines-test", version.ref = "kotlinx-coroutines" }
kotlinx-serialization-json = { module = "org.jetbrains.kotlinx:kotlinx-serialization-json", version.ref = "kotlinx-serialization" }
kotlinx-datetime = { module = "org.jetbrains.kotlinx:kotlinx-datetime", version.ref = "kotlinx-datetime" }
kermit = { module = "co.touchlab:kermit", version.ref = "kermit" }
sqlDelight-driver-sqlite = { module = "app.cash.sqldelight:sqlite-driver", version.ref = "sqlDelight" }
sqlDelight-driver-android = { module = "app.cash.sqldelight:android-driver", version.ref = "sqlDelight" }
sqlDelight-driver-native = { module = "app.cash.sqldelight:native-driver", version.ref = "sqlDelight" }
sqlDelight-driver-js = { module = "app.cash.sqldelight:web-worker-driver", version.ref = "sqlDelight" }
androidx-activityCompose = { module = "androidx.activity:activity-compose", version.ref = "androidx-activityCompose" }

[plugins]

multiplatform = { id = "org.jetbrains.kotlin.multiplatform", version.ref = "kotlin" }
android-library = { id = "com.android.library", version.ref = "agp" }
maven-publish = { id = "com.vanniktech.maven.publish", version.ref = "maven-publish" }
kotlinx-serialization = { id = "org.jetbrains.kotlin.plugin.serialization", version.ref = "kotlin" }
sqlDelight = { id = "app.cash.sqldelight", version.ref = "sqlDelight" }
compose = { id = "org.jetbrains.compose", version.ref = "compose" }
compose-compiler = { id = "org.jetbrains.kotlin.plugin.compose", version.ref = "kotlin" }
android-application = { id = "com.android.application", version.ref = "agp" }
</file>

<file path="sample/composeApp/src/androidMain/kotlin/sample/app/main.kt">
package sample.app

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.activity.enableEdgeToEdge

class AppActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent { App() }
    }
}
</file>

<file path="sample/composeApp/src/androidMain/AndroidManifest.xml">
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android">

    <application
            android:icon="@android:mipmap/sym_def_app_icon"
            android:label="sample"
            android:theme="@android:style/Theme.Material.NoActionBar">
        <activity
            android:name=".AppActivity"
            android:configChanges="orientation|screenSize|screenLayout|keyboardHidden"
            android:launchMode="singleInstance"
            android:windowSoftInputMode="adjustPan"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

</manifest>
</file>

<file path="sample/composeApp/src/commonMain/kotlin/sample/app/App.kt">
package sample.app

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.text.BasicText
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color

@Composable
fun App() {
    Box(
        modifier = Modifier.fillMaxSize().background(Color.White),
        contentAlignment = Alignment.Center
    ) {
    }
}
</file>

<file path="sample/composeApp/src/jvmMain/kotlin/sample/app/main.kt">
import androidx.compose.ui.unit.dp
import androidx.compose.ui.window.Window
import androidx.compose.ui.window.application
import androidx.compose.ui.window.rememberWindowState
import sample.app.App
import java.awt.Dimension

fun main() = application {
    Window(
        title = "sample",
        state = rememberWindowState(width = 800.dp, height = 600.dp),
        onCloseRequest = ::exitApplication,
    ) {
        window.minimumSize = Dimension(350, 600)
        App()
    }
}
</file>

<file path="sample/composeApp/build.gradle.kts">
import org.jetbrains.compose.desktop.application.dsl.TargetFormat

plugins {
    alias(libs.plugins.multiplatform)
    alias(libs.plugins.compose.compiler)
    alias(libs.plugins.compose)
    alias(libs.plugins.android.application)
}

kotlin {
    jvmToolchain(17)

    androidTarget()
    jvm()

    sourceSets {
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(project(":core"))
        }

        androidMain.dependencies {
            implementation(libs.androidx.activityCompose)
        }

        jvmMain.dependencies {
            implementation(compose.desktop.currentOs)
        }

    }
}

android {
    namespace = "sample.app"
    compileSdk = 35

    defaultConfig {
        minSdk = 21
        targetSdk = 35

        applicationId = "sample.app.androidApp"
        versionCode = 1
        versionName = "1.0.0"
    }
}

compose.desktop {
    application {
        mainClass = "MainKt"

        nativeDistributions {
            targetFormats(TargetFormat.Dmg, TargetFormat.Msi, TargetFormat.Deb)
            packageName = "sample"
            packageVersion = "1.0.0"
        }
    }
}
</file>

<file path=".gitignore">
*.iml
.gradle
.idea
.kotlin
.DS_Store
build
*/build
captures
.externalNativeBuild
.cxx
local.properties
xcuserdata/
Pods/
*.jks
*.gpg
*yarn.lock
</file>

<file path="build.gradle.kts">
plugins {
    alias(libs.plugins.multiplatform).apply(false)
    alias(libs.plugins.android.library).apply(false)
    alias(libs.plugins.maven.publish).apply(false)
    alias(libs.plugins.kotlinx.serialization).apply(false)
    alias(libs.plugins.sqlDelight).apply(false)
    alias(libs.plugins.android.application).apply(false)
}
</file>

<file path="gradle.properties">
#Gradle
org.gradle.jvmargs=-Xmx4G
org.gradle.caching=true
org.gradle.configuration-cache=true
org.gradle.daemon=true
org.gradle.parallel=true

#Kotlin
kotlin.code.style=official
kotlin.daemon.jvmargs=-Xmx4G
kotlin.native.binary.gc=cms
kotlin.incremental.wasm=true

#Android
android.useAndroidX=true
android.nonTransitiveRClass=true
</file>

<file path="gradlew">
#!/bin/sh

#
# Copyright © 2015-2021 the original authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

##############################################################################
#
#   Gradle start up script for POSIX generated by Gradle.
#
#   Important for running:
#
#   (1) You need a POSIX-compliant shell to run this script. If your /bin/sh is
#       noncompliant, but you have some other compliant shell such as ksh or
#       bash, then to run this script, type that shell name before the whole
#       command line, like:
#
#           ksh Gradle
#
#       Busybox and similar reduced shells will NOT work, because this script
#       requires all of these POSIX shell features:
#         * functions;
#         * expansions «$var», «${var}», «${var:-default}», «${var+SET}»,
#           «${var#prefix}», «${var%suffix}», and «$( cmd )»;
#         * compound commands having a testable exit status, especially «case»;
#         * various built-in commands including «command», «set», and «ulimit».
#
#   Important for patching:
#
#   (2) This script targets any POSIX shell, so it avoids extensions provided
#       by Bash, Ksh, etc; in particular arrays are avoided.
#
#       The "traditional" practice of packing multiple parameters into a
#       space-separated string is a well documented source of bugs and security
#       problems, so this is (mostly) avoided, by progressively accumulating
#       options in "$@", and eventually passing that to Java.
#
#       Where the inherited environment variables (DEFAULT_JVM_OPTS, JAVA_OPTS,
#       and GRADLE_OPTS) rely on word-splitting, this is performed explicitly;
#       see the in-line comments for details.
#
#       There are tweaks for specific operating systems such as AIX, CygWin,
#       Darwin, MinGW, and NonStop.
#
#   (3) This script is generated from the Groovy template
#       https://github.com/gradle/gradle/blob/HEAD/subprojects/plugins/src/main/resources/org/gradle/api/internal/plugins/unixStartScript.txt
#       within the Gradle project.
#
#       You can find Gradle at https://github.com/gradle/gradle/.
#
##############################################################################

# Attempt to set APP_HOME

# Resolve links: $0 may be a link
app_path=$0

# Need this for daisy-chained symlinks.
while
    APP_HOME=${app_path%"${app_path##*/}"}  # leaves a trailing /; empty if no leading path
    [ -h "$app_path" ]
do
    ls=$( ls -ld "$app_path" )
    link=${ls#*' -> '}
    case $link in             #(
      /*)   app_path=$link ;; #(
      *)    app_path=$APP_HOME$link ;;
    esac
done

# This is normally unused
# shellcheck disable=SC2034
APP_BASE_NAME=${0##*/}
# Discard cd standard output in case $CDPATH is set (https://github.com/gradle/gradle/issues/25036)
APP_HOME=$( cd "${APP_HOME:-./}" > /dev/null && pwd -P ) || exit

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD=maximum

warn () {
    echo "$*"
} >&2

die () {
    echo
    echo "$*"
    echo
    exit 1
} >&2

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
nonstop=false
case "$( uname )" in                #(
  CYGWIN* )         cygwin=true  ;; #(
  Darwin* )         darwin=true  ;; #(
  MSYS* | MINGW* )  msys=true    ;; #(
  NONSTOP* )        nonstop=true ;;
esac

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar


# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD=$JAVA_HOME/jre/sh/java
    else
        JAVACMD=$JAVA_HOME/bin/java
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD=java
    if ! command -v java >/dev/null 2>&1
    then
        die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
fi

# Increase the maximum file descriptors if we can.
if ! "$cygwin" && ! "$darwin" && ! "$nonstop" ; then
    case $MAX_FD in #(
      max*)
        # In POSIX sh, ulimit -H is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        MAX_FD=$( ulimit -H -n ) ||
            warn "Could not query maximum file descriptor limit"
    esac
    case $MAX_FD in  #(
      '' | soft) :;; #(
      *)
        # In POSIX sh, ulimit -n is undefined. That's why the result is checked to see if it worked.
        # shellcheck disable=SC2039,SC3045
        ulimit -n "$MAX_FD" ||
            warn "Could not set maximum file descriptor limit to $MAX_FD"
    esac
fi

# Collect all arguments for the java command, stacking in reverse order:
#   * args from the command line
#   * the main class name
#   * -classpath
#   * -D...appname settings
#   * --module-path (only if needed)
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, and GRADLE_OPTS environment variables.

# For Cygwin or MSYS, switch paths to Windows format before running java
if "$cygwin" || "$msys" ; then
    APP_HOME=$( cygpath --path --mixed "$APP_HOME" )
    CLASSPATH=$( cygpath --path --mixed "$CLASSPATH" )

    JAVACMD=$( cygpath --unix "$JAVACMD" )

    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    for arg do
        if
            case $arg in                                #(
              -*)   false ;;                            # don't mess with options #(
              /?*)  t=${arg#/} t=/${t%%/*}              # looks like a POSIX filepath
                    [ -e "$t" ] ;;                      #(
              *)    false ;;
            esac
        then
            arg=$( cygpath --path --ignore --mixed "$arg" )
        fi
        # Roll the args list around exactly as many times as the number of
        # args, so each arg winds up back in the position where it started, but
        # possibly modified.
        #
        # NB: a `for` loop captures its iteration list before it begins, so
        # changing the positional parameters here affects neither the number of
        # iterations, nor the values presented in `arg`.
        shift                   # remove old arg
        set -- "$@" "$arg"      # push replacement arg
    done
fi


# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS='"-Xmx64m" "-Xms64m"'

# Collect all arguments for the java command:
#   * DEFAULT_JVM_OPTS, JAVA_OPTS, JAVA_OPTS, and optsEnvironmentVar are not allowed to contain shell fragments,
#     and any embedded shellness will be escaped.
#   * For example: A user cannot expect ${Hostname} to be expanded, as it is an environment variable and will be
#     treated as '${Hostname}' itself on the command line.

set -- \
        "-Dorg.gradle.appname=$APP_BASE_NAME" \
        -classpath "$CLASSPATH" \
        org.gradle.wrapper.GradleWrapperMain \
        "$@"

# Stop when "xargs" is not available.
if ! command -v xargs >/dev/null 2>&1
then
    die "xargs is not available"
fi

# Use "xargs" to parse quoted args.
#
# With -n1 it outputs one arg per line, with the quotes and backslashes removed.
#
# In Bash we could simply go:
#
#   readarray ARGS < <( xargs -n1 <<<"$var" ) &&
#   set -- "${ARGS[@]}" "$@"
#
# but POSIX shell has neither arrays nor command substitution, so instead we
# post-process each arg (as a line of input to sed) to backslash-escape any
# character that might be a shell metacharacter, then use eval to reverse
# that process (while maintaining the separation between arguments), and wrap
# the whole thing up as a single "set" statement.
#
# This will of course break if any of these variables contains a newline or
# an unmatched quote.
#

eval "set -- $(
        printf '%s\n' "$DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS" |
        xargs -n1 |
        sed ' s~[^-[:alnum:]+,./:=@_]~\\&~g; ' |
        tr '\n' ' '
    )" '"$@"'

exec "$JAVACMD" "$@"
</file>

<file path="gradlew.bat">
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega
</file>

<file path="README.MD">
# SeforimLibrary

Kotlin Multiplatform Library

### Run Sample App

 - Desktop JVM: `./gradlew :sample:composeApp:run`
 - Android: `open project in Android Studio and run the sample app`

### Publish to MavenLocal

1) Run `./gradlew :shared:publishToMavenLocal`
2) Open `~/.m2/repository/io/github/kdroidfilter/seforimlibrary/`

### Publish to MavenCentral

1) Create an account and a namespace on Sonatype:  
   https://central.sonatype.org/register/central-portal/#create-an-account
2) Add developer id, name, email and the project url to  
   `./shared/build.gradle.kts`
3) Generate a GPG key:  
   https://getstream.io/blog/publishing-libraries-to-mavencentral-2021/#generating-a-gpg-key-pair
   ```
   gpg --full-gen-key
   gpg --keyserver keyserver.ubuntu.com --send-keys XXXXXXXX
   gpg --export-secret-key XXXXXXXX > XXXXXXXX.gpg
   ```
4) Add these lines to `gradle.properties`:
   ```
   signing.keyId=XXXXXXXX
   signing.password=[key password]
   signing.secretKeyRingFile=../XXXXXXXX.gpg
   mavenCentralUsername=[generated username]
   mavenCentralPassword=[generated password]
   ```
5) Run `./gradlew :shared:publishAndReleaseToMavenCentral --no-configuration-cache`
</file>

<file path="settings.gradle.kts">
rootProject.name = "SeforimLibrary"

pluginManagement {
    repositories {
        google {
            content { 
              	includeGroupByRegex("com\\.android.*")
              	includeGroupByRegex("com\\.google.*")
              	includeGroupByRegex("androidx.*")
              	includeGroupByRegex("android.*")
            }
        }
        gradlePluginPortal()
        mavenCentral()
    }
}

dependencyResolutionManagement {
    repositories {
        google {
            content { 
              	includeGroupByRegex("com\\.android.*")
              	includeGroupByRegex("com\\.google.*")
              	includeGroupByRegex("androidx.*")
              	includeGroupByRegex("android.*")
            }
        }
        mavenCentral()
    }
}
include(":core")
include(":dao")
include(":generator")
include(":sample:composeApp")
</file>

</files>
